aspen:
  minimal_context: true

  # Move the original mmengine inference pipeline here so the CLI can use it
  inference_pipeline:
    - type: LoadImageFromFile
    - type: HmCrop
      keys: [img]
      save_clipped_images: true
    - type: HmImageToTensor
      keys: [img]
      # scale_factor: 255.0
    - type: HmResize
      # We will scale downm the image to fit within img_scale
      # before HmPad maybe pads it to be this size
      # vimg_scale: [1312, 480]
      img_scale: [1632, 608]
      # img_scale: [1952, 704]
      # img_scale: [1984, 736]
      keep_ratio: true
      interpolation: area
    - type: HmImageColorAdjust
      # No-op by default; CLI can set white_balance/brightness/contrast/gamma
      # Example:
      # white_balance: [1.05, 1.0, 0.95]
      # or temperature in Kelvin (e.g., 3500k):
      # white_balance_temp: 3500k
      white_balance: GLOBAL.camera.color.white_balance
      brightness: GLOBAL.camera.color.brightness
      contrast: GLOBAL.camera.color.contrast
      gamma: GLOBAL.camera.color.gamma
    - type: HmPad
      pad_val: 114.0
      # size_divisor: 32
      # size: [736, 1984]  # Actual size of tensor, which is H-W ordering
      # size: [480, 1312]  # Actual size of tensor, which is H-W ordering
      size: [608, 1632]  # Actual size of tensor, which is H-W ordering
      # size: [480, 1312]
    - type: mmdet.PackTrackInputs
      meta_keys: [img_metas, hm_real_time_fps]
    - type: HmRealTime
      enabled: false
      scale: 1.0

  # Optional per-camera color pipelines for stitching inputs.
  # These operate on the raw left/right camera frames *before* stitching and
  # can be driven at runtime via the game.stitching.left/right.color blocks.
  left_stitch_pipeline:
    - type: HmImageColorAdjust
      keys: [img]
      # Runtime values are pulled from args.game_config using these paths.
      # If missing, the transform is a no-op.
      config_paths:
        - [game, stitching, left, color]
        - [game, stitching, left]
      refresh_from_config: true

  right_stitch_pipeline:
    - type: HmImageColorAdjust
      keys: [img]
      config_paths:
        - [game, stitching, right, color]
        - [game, stitching, right]
      refresh_from_config: true

  # Default camera post-processing pipeline (was in hm_end_to_end.py)
  video_out_pipeline:
    - type: HmConfigureScoreboard
    - type: HmCaptureScoreboard
    - type: HmPerspectiveRotation
      pre_clip: true
    - type: HmCropToVideoFrame
    - type: HmRenderScoreboard
      image_labels: [img, end_zone_img]
    - type: HmImageColorAdjust
      # Runtime-tunable via camera UI (PlayTracker) or CLI
      # Defaults to no-op; UI writes values under rink.camera.color
      # white_balance: GLOBAL.camera.color.white_balance
      # brightness: GLOBAL.camera.color.brightness
      # contrast: GLOBAL.camera.color.contrast
      # gamma: GLOBAL.camera.color.gamma
    - type: HmUnsharpMask
      enabled: false
      image_label: img
    - type: HmImageOverlays
      watermark_config:
        image: images/sports_ai_watermark.png

  trunks:
    image_prep:
      class: hmlib.aspen.trunks.image_prep.ImagePrepTrunk
      depends: []
      params: {}

    model_factory:
      class: hmlib.aspen.trunks.model_factory.ModelFactoryTrunk
      depends: []
      enabled: true
      params:
        model_class: hmlib.models.end_to_end.HmEndToEnd
        # Pure YAML detector definition (converted from mmengine config)
        # No detector/tracker coupling here; post_* pipelines not used for rink mask
        post_tracking_pipeline:
          - type: HmNumberClassifier
            image_label: original_images
            enabled: false

    detector_factory:
      class: hmlib.aspen.trunks.detector_factory.DetectorFactoryTrunk
      depends: []
      enabled: true
      params:
        detector_yaml: hmlib/config/aspen/models/bytetrack_yolox_s.detector.yaml
        # detector_yaml: hmlib/config/aspen/models/hm_crowdhuman_yolov8_m_1984_736.detector.yaml
        data_preprocessor:
          type: TrackDataPreprocessor
          pad_size_divisor: 32
          use_det_processor: true

    boundaries:
      class: hmlib.aspen.trunks.boundaries.BoundariesTrunk
      depends: [model_factory]
      params: {}

    detector:
      class: hmlib.aspen.trunks.detector.DetectorInferenceTrunk
      depends: [image_prep, detector_factory]
      params: {}

    save_detections:
      class: hmlib.aspen.trunks.save.SaveDetectionsTrunk
      depends: [detector]
      enabled: false
      params: {}

    ice_config:
      class: hmlib.aspen.trunks.ice_rink_boundaries.IceRinkSegmConfigTrunk
      depends: [image_prep]
      params: {}

    ice_boundaries:
      class: hmlib.aspen.trunks.ice_rink_boundaries.IceRinkSegmBoundariesTrunk
      depends: [detector, ice_config]
      params:
        enabled: true
        # Optional cap on detections that survive the rink mask.
        # If set, only the top-K scores inside the mask are kept.
        max_detections_in_mask: 50

    tracker:
      class: hmlib.aspen.trunks.tracker.TrackerTrunk
      depends: [detector, ice_boundaries, model_factory, boundaries]
      params:
        # tracker_class: hockeymom.core.HmByteTrackerCuda  # Uncomment to enable static-shape CUDA tracker
        tracker_class: hockeymom.core.HmByteTrackerCudaStatic  # Uncomment to enable static-shape CUDA tracker
        tracker_kwargs:
          device: cuda:0
          max_detections: 256
          max_tracks: 100

    save_tracking:
      class: hmlib.aspen.trunks.save.SaveTrackingTrunk
      depends: [tracker]
      enabled: false
      params: {}

    # Optional camera controller (rule-based by default). Enable transformer by
    # setting controller: transformer and model_path to your checkpoint.
    camera_controller:
      class: hmlib.aspen.trunks.camera_controller.CameraControllerTrunk
      depends: [tracker]
      params:
        controller: rule
        model_path: null
        window: 8

    postprocess:
      class: hmlib.aspen.trunks.postprocess.CamPostProcessTrunk
      depends: [tracker, camera_controller, ice_config]
      params: {}
